"""
Radio Cog - G≈Ç√≥wne komendy Discord dla ACE-Step Radio Bot
"""

import discord
from discord.ext import commands
from discord import app_commands
from typing import Optional
import asyncio
import json
import time
from pathlib import Path
from datetime import datetime

# Local imports
from ..utils.radio_engine import RadioEngine
from ..utils.queue_manager import RadioQueue, TrackInfo
from ..utils.audio_converter import AudioConverter
from ..utils.metrics import get_metrics
from ..config.constants import ERROR_MESSAGES, SUCCESS_MESSAGES, SupportedLanguages, MusicGenres, MusicThemes
from ..config.settings import *

class RadioCog(commands.Cog):
    """G≈Ç√≥wny cog z komendami Discord Radio"""
    
    def __init__(self, bot):
        """Inicjalizacja cog"""
        self.bot = bot
        self.radio_engine = RadioEngine()
        self.voice_clients = {}  # guild_id: discord.VoiceClient
        self.queues = {}        # guild_id: RadioQueue  
        self.playing_tasks = {} # guild_id: asyncio.Task
        
        # Load presets
        presets_path = Path(__file__).parent.parent / "data" / "presets.json"
        try:
            with open(presets_path, 'r', encoding='utf-8') as f:
                self.presets = json.load(f)
        except Exception as e:
            print(f"Failed to load presets: {e}")
            self.presets = {}
        
        print("RadioCog initialized")
    
    def get_queue(self, guild_id: int) -> RadioQueue:
        """Pobierz lub stw√≥rz kolejkƒô dla serwera"""
        if guild_id not in self.queues:
            self.queues[guild_id] = RadioQueue()
        return self.queues[guild_id]
    
    def create_embed(self, title: str, description: str, color: discord.Color = discord.Color.blue()) -> discord.Embed:
        """Stw√≥rz standardowy embed"""
        embed = discord.Embed(title=title, description=description, color=color)
        embed.set_footer(text="ACE-Step Radio Bot")
        return embed
    
    def create_error_embed(self, message: str) -> discord.Embed:
        """Stw√≥rz embed z b≈Çƒôdem"""
        return self.create_embed("‚ùå B≈ÇƒÖd", message, discord.Color.red())
    
    def create_success_embed(self, message: str) -> discord.Embed:
        """Stw√≥rz embed z sukcesem"""
        return self.create_embed("‚úÖ Sukces", message, discord.Color.green())

    # ==================== PODSTAWOWE KOMENDY ====================
    
    @app_commands.command(name="radio_join", description="Do≈ÇƒÖcz do kana≈Çu g≈Çosowego")
    async def radio_join(self, interaction: discord.Interaction):
        """Do≈ÇƒÖcz do kana≈Çu g≈Çosowego"""
        # Track command
        metrics = get_metrics()
        if metrics:
            metrics.record_command_execution("radio_join")
        
        # Sprawd≈∫ czy user jest w voice channel
        if not interaction.user.voice:
            embed = self.create_error_embed(ERROR_MESSAGES["not_in_voice"])
            await interaction.response.send_message(embed=embed)
            return
        
        channel = interaction.user.voice.channel
        
        # Sprawd≈∫ czy bot ju≈º po≈ÇƒÖczony
        if interaction.guild.id in self.voice_clients:
            # Przenie≈õ do nowego kana≈Çu
            await self.voice_clients[interaction.guild.id].move_to(channel)
        else:
            # Po≈ÇƒÖcz do kana≈Çu
            try:
                voice_client = await channel.connect()
                self.voice_clients[interaction.guild.id] = voice_client
            except Exception as e:
                embed = self.create_error_embed(f"Nie mogƒô do≈ÇƒÖczyƒá do kana≈Çu: {str(e)}")
                await interaction.response.send_message(embed=embed)
                return
        
        embed = self.create_success_embed(SUCCESS_MESSAGES["joined"].format(channel=channel.name))
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_play", description="Zagraj utw√≥r z podanymi parametrami")
    @app_commands.describe(
        genre="Gatunek muzyki",
        theme="Temat utworu", 
        language="Jƒôzyk tekst√≥w",
        duration="D≈Çugo≈õƒá utworu w sekundach"
    )
    async def radio_play(self, interaction: discord.Interaction,
                        genre: str = DEFAULT_GENRE,
                        theme: str = DEFAULT_THEME, 
                        language: str = DEFAULT_LANGUAGE,
                        duration: int = DEFAULT_DURATION):
        """G≈Ç√≥wna komenda odtwarzania"""
        
        # Track command and parameters
        metrics = get_metrics()
        if metrics:
            metrics.record_command_execution("radio_play")
        
        # Sprawd≈∫ czy bot w voice channel
        if interaction.guild.id not in self.voice_clients:
            embed = self.create_error_embed(ERROR_MESSAGES["bot_not_connected"])
            await interaction.response.send_message(embed=embed)
            return
        
        voice_client = self.voice_clients[interaction.guild.id]
        if not voice_client.is_connected():
            embed = self.create_error_embed(ERROR_MESSAGES["bot_not_connected"])
            await interaction.response.send_message(embed=embed)
            return
        
        # Defer response - generowanie mo≈ºe trwaƒá d≈Çugo
        await interaction.response.defer()
        
        try:
            # Get/create RadioQueue dla guild
            queue = self.get_queue(interaction.guild.id)
            
            # Update queue settings je≈õli podane
            queue.set_genre(genre)
            queue.set_theme(theme)
            queue.set_language(language)
            
            # Validate duration vs max_length
            actual_duration = min(duration, queue.max_length)
            if actual_duration != duration:
                await interaction.followup.send(
                    f"‚ö†Ô∏è D≈Çugo≈õƒá skr√≥cona z {duration}s do {actual_duration}s (max: {queue.max_length}s)"
                )
            
            # Generate track
            status_embed = self.create_embed("üéµ Generowanie", "Tworzƒô utw√≥r, to mo≈ºe potrwaƒá chwilƒô...")
            await interaction.followup.send(embed=status_embed)
            
            start_time = time.time()
            
            # Generate lyrics
            lyrics = await self.radio_engine.generate_lyrics_async(genre, theme, language)
            
            # Generate music
            tags = f"{genre} song about {theme}"
            audio_path = await self.radio_engine.generate_music_async(
                lyrics, tags, actual_duration, queue.max_length
            )
            
            generation_time = time.time() - start_time
            
            # Track generation metrics
            if metrics:
                metrics.record_song_generation(genre, language, generation_time)
            
            # Convert for Discord
            discord_audio_path = self.radio_engine.convert_for_discord(audio_path)
            
            # Stop current playback if any
            if voice_client.is_playing():
                voice_client.stop()
            
            # Play audio
            source = discord.FFmpegPCMAudio(str(discord_audio_path))
            voice_client.play(source)
            
            # Create track info
            track = TrackInfo(
                path=audio_path,
                genre=genre,
                theme=theme,
                language=language,
                duration=actual_duration,
                lyrics=lyrics,
                generated_at=datetime.now(),
                title=f"{theme.title()}",
                artist="AI Radio"
            )
            
            # Update current track
            queue.current_track = track
            
            # Create success embed with track info
            embed = self.create_embed(
                "üéµ Teraz gra",
                f"**{track.title}**\n"
                f"Gatunek: {genre}\n"
                f"Temat: {theme}\n"
                f"Jƒôzyk: {language}\n"
                f"D≈Çugo≈õƒá: {actual_duration}s",
                discord.Color.green()
            )
            
            await interaction.edit_original_response(embed=embed)
            
            # Start auto-queue task je≈õli w≈ÇƒÖczone
            if queue.auto_queue and interaction.guild.id not in self.playing_tasks:
                task = asyncio.create_task(self._auto_queue_task(interaction.guild.id))
                self.playing_tasks[interaction.guild.id] = task
            
        except Exception as e:
            # Track error
            if metrics:
                metrics.record_error("radio_play_generation")
            
            embed = self.create_error_embed(f"B≈ÇƒÖd generowania: {str(e)}")
            await interaction.edit_original_response(embed=embed)
    
    @app_commands.command(name="radio_skip", description="Pomi≈Ñ obecny utw√≥r")
    async def radio_skip(self, interaction: discord.Interaction):
        """Skip current track"""
        if interaction.guild.id not in self.voice_clients:
            embed = self.create_error_embed(ERROR_MESSAGES["bot_not_connected"])
            await interaction.response.send_message(embed=embed)
            return
        
        voice_client = self.voice_clients[interaction.guild.id]
        
        if voice_client.is_playing():
            voice_client.stop()
            embed = self.create_success_embed(SUCCESS_MESSAGES["skipped"])
        else:
            embed = self.create_error_embed("Nic nie gra")
        
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_stop", description="Zatrzymaj radio i opu≈õƒá kana≈Ç")
    async def radio_stop(self, interaction: discord.Interaction):
        """Stop and cleanup"""
        guild_id = interaction.guild.id
        
        # Stop playback
        if guild_id in self.voice_clients:
            voice_client = self.voice_clients[guild_id]
            if voice_client.is_playing():
                voice_client.stop()
            
            # Disconnect
            await voice_client.disconnect()
            del self.voice_clients[guild_id]
        
        # Cancel auto-queue task
        if guild_id in self.playing_tasks:
            self.playing_tasks[guild_id].cancel()
            del self.playing_tasks[guild_id]
        
        # Clear queue
        if guild_id in self.queues:
            self.queues[guild_id].clear_queue()
        
        embed = self.create_success_embed(SUCCESS_MESSAGES["stopped"])
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_upload", description="Wrzuƒá plik z obecnym utworem na kana≈Ç")
    @app_commands.describe(track_index="Indeks utworu w kolejce (opcjonalny)")
    async def radio_upload(self, interaction: discord.Interaction, track_index: Optional[int] = None):
        """Wrzuƒá plik z piosenkƒÖ na kana≈Ç"""
        
        # Track command
        metrics = get_metrics()
        if metrics:
            metrics.record_command_execution("radio_upload")
        
        queue = self.get_queue(interaction.guild.id)
        
        # Pobierz ≈õcie≈ºkƒô pliku
        audio_path = queue.get_track_path(track_index)
        
        if audio_path is None:
            embed = self.create_error_embed(ERROR_MESSAGES["no_track"])
            await interaction.response.send_message(embed=embed)
            return
        
        await interaction.response.defer()
        
        try:
            # Przygotuj plik do uploadu
            upload_path = self.radio_engine.prepare_upload_file(audio_path, format="mp3")
            
            # Sprawd≈∫ rozmiar pliku
            file_size = upload_path.stat().st_size
            if file_size > MAX_FILE_SIZE:
                embed = self.create_error_embed(ERROR_MESSAGES["file_too_large"])
                await interaction.followup.send(embed=embed)
                return
            
            # Upload file
            file = discord.File(str(upload_path), filename=f"ace_radio_{upload_path.name}")
            
            # Get track info for embed
            track = queue.current_track if track_index is None else queue.queue[track_index]
            track_info = f"Gatunek: {track.genre}, Temat: {track.theme}" if track else ""
            
            embed = self.create_success_embed(
                f"üì§ {SUCCESS_MESSAGES['uploaded']}\n{track_info}"
            )
            
            await interaction.followup.send(embed=embed, file=file)
            
            # Track successful upload
            if metrics:
                metrics.record_upload()
            
            # Opcjonalnie usu≈Ñ plik po uploadzie
            try:
                upload_path.unlink()
            except Exception:
                pass
            
        except Exception as e:
            # Track upload error
            if metrics:
                metrics.record_error("radio_upload")
            
            embed = self.create_error_embed(f"B≈ÇƒÖd uploadu: {str(e)}")
            await interaction.followup.send(embed=embed)

    # ==================== USTAWIENIA ====================
    
    @app_commands.command(name="radio_genre", description="Ustaw gatunek muzyki")
    @app_commands.describe(genre="Nowy gatunek muzyki")
    async def radio_genre(self, interaction: discord.Interaction, genre: str):
        """Ustaw gatunek"""
        queue = self.get_queue(interaction.guild.id)
        
        if queue.set_genre(genre):
            embed = self.create_success_embed(
                SUCCESS_MESSAGES["setting_updated"].format(setting="Gatunek", value=genre)
            )
        else:
            valid_genres = ", ".join(["pop", "rock", "jazz", "edm", "classical", "hip-hop"])
            embed = self.create_error_embed(f"Nieprawid≈Çowy gatunek. Dostƒôpne: {valid_genres}")
        
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_theme", description="Ustaw temat utwor√≥w")
    @app_commands.describe(theme="Nowy temat utwor√≥w")
    async def radio_theme(self, interaction: discord.Interaction, theme: str):
        """Ustaw temat"""
        queue = self.get_queue(interaction.guild.id)
        queue.set_theme(theme)
        
        embed = self.create_success_embed(
            SUCCESS_MESSAGES["setting_updated"].format(setting="Temat", value=theme)
        )
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_language", description="Ustaw jƒôzyk tekst√≥w")
    @app_commands.describe(language="Jƒôzyk dla tekst√≥w utwor√≥w")
    async def radio_language(self, interaction: discord.Interaction, language: str):
        """Ustaw jƒôzyk"""
        queue = self.get_queue(interaction.guild.id)
        
        if queue.set_language(language):
            embed = self.create_success_embed(
                SUCCESS_MESSAGES["setting_updated"].format(setting="Jƒôzyk", value=language)
            )
        else:
            valid_languages = ", ".join(queue.SUPPORTED_LANGUAGES)
            embed = self.create_error_embed(
                ERROR_MESSAGES["invalid_language"].format(languages=valid_languages)
            )
        
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_maxlength", description="Ustaw maksymalnƒÖ d≈Çugo≈õƒá utwor√≥w")
    @app_commands.describe(seconds="Maksymalna d≈Çugo≈õƒá w sekundach (30-300)")
    async def radio_maxlength(self, interaction: discord.Interaction, seconds: int):
        """Ustaw maksymalnƒÖ d≈Çugo≈õƒá"""
        queue = self.get_queue(interaction.guild.id)
        
        if queue.set_max_length(seconds):
            embed = self.create_success_embed(
                SUCCESS_MESSAGES["setting_updated"].format(setting="Maks. d≈Çugo≈õƒá", value=f"{seconds}s")
            )
        else:
            embed = self.create_error_embed(
                ERROR_MESSAGES["invalid_duration"].format(min=MAX_LENGTH_MIN, max=MAX_LENGTH_MAX)
            )
        
        await interaction.response.send_message(embed=embed)

    # ==================== KOLEJKA ====================
    
    @app_commands.command(name="radio_auto", description="W≈ÇƒÖcz/wy≈ÇƒÖcz automatyczne dodawanie utwor√≥w")
    @app_commands.describe(enabled="Czy w≈ÇƒÖczyƒá auto-queue")
    async def radio_auto(self, interaction: discord.Interaction, enabled: bool):
        """Toggle auto-queue"""
        queue = self.get_queue(interaction.guild.id)
        queue.set_auto_queue(enabled)
        
        status = "w≈ÇƒÖczone" if enabled else "wy≈ÇƒÖczone"
        embed = self.create_success_embed(f"Auto-queue {status}")
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_queue_list", description="Poka≈º kolejkƒô utwor√≥w")
    async def radio_queue_list(self, interaction: discord.Interaction):
        """Poka≈º kolejkƒô"""
        queue = self.get_queue(interaction.guild.id)
        queue_list = queue.get_queue_list()
        
        if not queue_list:
            embed = self.create_embed("üìã Kolejka", "Kolejka jest pusta")
        else:
            description = "\n".join([
                f"{i+1}. {track['title']} ({track['duration']})"
                for i, track in enumerate(queue_list[:10])  # Show max 10
            ])
            
            if len(queue_list) > 10:
                description += f"\n... i {len(queue_list) - 10} wiƒôcej"
            
            embed = self.create_embed("üìã Kolejka", description)
        
        await interaction.response.send_message(embed=embed)

    # ==================== INFO ====================
    
    @app_commands.command(name="radio_settings", description="Poka≈º obecne ustawienia")
    async def radio_settings(self, interaction: discord.Interaction):
        """Poka≈º ustawienia"""
        queue = self.get_queue(interaction.guild.id)
        status = queue.get_queue_status()
        
        embed = self.create_embed(
            "‚öôÔ∏è Ustawienia Radio",
            f"**Gatunek:** {status['genre']}\n"
            f"**Temat:** {status['theme']}\n"
            f"**Jƒôzyk:** {status['language']}\n"
            f"**Maks. d≈Çugo≈õƒá:** {status['max_length']}s\n"
            f"**Auto-queue:** {'Tak' if status['auto_queue'] else 'Nie'}\n"
            f"**Utwor√≥w w kolejce:** {status['queue_length']}\n"
            f"**Obecny utw√≥r:** {status['current_track'] or 'Brak'}"
        )
        
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_nowplaying", description="Co teraz gra")
    async def radio_nowplaying(self, interaction: discord.Interaction):
        """Co gra teraz"""
        queue = self.get_queue(interaction.guild.id)
        
        if queue.current_track:
            track = queue.current_track
            embed = self.create_embed(
                "üéµ Teraz gra",
                f"**{track.title}**\n"
                f"Gatunek: {track.genre}\n"
                f"Temat: {track.theme}\n"
                f"Jƒôzyk: {track.language}\n"
                f"D≈Çugo≈õƒá: {track.duration}s\n"
                f"Wygenerowano: {track.generated_at.strftime('%H:%M:%S')}"
            )
        else:
            embed = self.create_embed("üéµ Teraz gra", "Nic nie gra")
        
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_preset", description="U≈ºyj gotowego presetu")
    @app_commands.describe(preset_name="Nazwa presetu")
    async def radio_preset(self, interaction: discord.Interaction, preset_name: str):
        """U≈ºyj presetu"""
        if preset_name not in self.presets:
            available = ", ".join(self.presets.keys())
            embed = self.create_error_embed(f"Nieznany preset. Dostƒôpne: {available}")
            await interaction.response.send_message(embed=embed)
            return
        
        preset = self.presets[preset_name]
        queue = self.get_queue(interaction.guild.id)
        
        # Apply preset settings
        queue.set_genre(preset["genre"])
        queue.set_theme(preset["theme"])
        if preset["language"] != "current":
            queue.set_language(preset["language"])
        
        embed = self.create_success_embed(
            f"üé® Preset '{preset_name}' zastosowany!\n"
            f"{preset['description']}\n"
            f"Gatunek: {preset['genre']}, Temat: {preset['theme']}"
        )
        await interaction.response.send_message(embed=embed)

    # ==================== POMOCY ====================
    
    @app_commands.command(name="radio_help", description="Poka≈º wszystkie komendy")
    async def radio_help(self, interaction: discord.Interaction):
        """Poka≈º pomoc"""
        help_text = """
**üéµ ACE-Step Discord Radio Bot**

**Podstawowe:**
‚Ä¢ `/radio_join` - Do≈ÇƒÖcz do kana≈Çu
‚Ä¢ `/radio_play` - Zagraj muzykƒô
‚Ä¢ `/radio_skip` - Pomi≈Ñ utw√≥r  
‚Ä¢ `/radio_stop` - Zatrzymaj radio
‚Ä¢ `/radio_upload` - Wrzuƒá plik z utworem na kana≈Ç

**Ustawienia:**
‚Ä¢ `/radio_genre` - Ustaw gatunek
‚Ä¢ `/radio_theme` - Ustaw temat
‚Ä¢ `/radio_language` - Ustaw jƒôzyk
‚Ä¢ `/radio_maxlength` - Maks d≈Çugo≈õƒá

**Kolejka:**
‚Ä¢ `/radio_auto` - Auto-dodawanie utwor√≥w
‚Ä¢ `/radio_queue_list` - Poka≈º kolejkƒô

**Info:**
‚Ä¢ `/radio_settings` - Obecne ustawienia
‚Ä¢ `/radio_nowplaying` - Co gra
‚Ä¢ `/radio_preset` - Gotowe kombinacje
‚Ä¢ `/radio_stats` - Statystyki bota

üí° Wszystkie parametry sƒÖ opcjonalne!
        """
        
        embed = self.create_embed("üìö Pomoc", help_text.strip())
        await interaction.response.send_message(embed=embed)
    
    @app_commands.command(name="radio_stats", description="Poka≈º statystyki bota")
    async def radio_stats(self, interaction: discord.Interaction):
        """Poka≈º statystyki bota"""
        metrics = get_metrics()
        if not metrics:
            embed = self.create_error_embed("Statystyki nie sƒÖ dostƒôpne")
            await interaction.response.send_message(embed=embed)
            return
        
        stats = metrics.get_summary_stats()
        uptime = stats["uptime"]
        
        embed = self.create_embed(
            "üìä Statystyki Bota",
            f"**‚è±Ô∏è Czas dzia≈Çania:** {uptime['days']}d {uptime['hours']}h {uptime['minutes']}m\n"
            f"**üéµ Utwory wygenerowane:** {stats['generation']['total_songs']}\n"
            f"**‚ö° ≈öredni czas generowania:** {stats['generation']['avg_time']}s\n"
            f"**üìà Utwor√≥w na godzinƒô:** {stats['generation']['songs_per_hour']}\n"
            f"**üéÆ Wykonane komendy:** {stats['activity']['total_commands']}\n"
            f"**üì§ Pliki wys≈Çane:** {stats['activity']['total_uploads']}\n"
            f"**‚ùå B≈Çƒôdy:** {stats['activity']['total_errors']}\n"
            f"**üåê Aktywne serwery:** {stats['activity']['active_guilds']}\n"
            f"**üîä Po≈ÇƒÖczenia g≈Çosowe:** {stats['activity']['voice_connections']}\n"
            f"**üíæ Szczytowe RAM:** {stats['performance']['peak_memory_mb']}MB\n"
            f"**üéØ ≈örednia kolejka:** {stats['performance']['avg_queue_length']}"
        )
        
        # Add popular genres/languages if available
        if stats['popular']['top_genres']:
            top_genres = ", ".join([f"{k}({v})" for k, v in list(stats['popular']['top_genres'].items())[:3]])
            embed.add_field(name="üé∂ Popularne gatunki", value=top_genres, inline=True)
        
        if stats['popular']['top_languages']:
            top_languages = ", ".join([f"{k}({v})" for k, v in list(stats['popular']['top_languages'].items())[:3]])
            embed.add_field(name="üåç Popularne jƒôzyki", value=top_languages, inline=True)
        
        await interaction.response.send_message(embed=embed)
    
    # ==================== HELPER METHODS ====================
    
    async def _auto_queue_task(self, guild_id: int):
        """Background task dla auto-queue"""
        try:
            while guild_id in self.voice_clients:
                queue = self.get_queue(guild_id)
                voice_client = self.voice_clients[guild_id]
                
                # Fill buffer if needed
                await queue.ensure_buffer_full(self.radio_engine)
                
                # If nothing playing and queue has tracks, play next
                if not voice_client.is_playing() and queue.queue:
                    track = queue.get_next_track()
                    if track:
                        try:
                            # Convert for Discord
                            discord_audio_path = self.radio_engine.convert_for_discord(track.path)
                            source = discord.FFmpegPCMAudio(str(discord_audio_path))
                            voice_client.play(source)
                            print(f"Auto-playing: {track.title}")
                        except Exception as e:
                            print(f"Auto-play failed: {e}")
                
                await asyncio.sleep(5)  # Check every 5 seconds
                
        except asyncio.CancelledError:
            print(f"Auto-queue task cancelled for guild {guild_id}")
        except Exception as e:
            print(f"Auto-queue task error: {e}")

async def setup(bot):
    """Setup function dla cog"""
    await bot.add_cog(RadioCog(bot))
